{
  "version": 3,
  "file": "ngx-emoji.umd.min.js",
  "sources": [
    "ng://ngx-emoji/src/main/ngx-emoji.service.ts",
    "ng://ngx-emoji/src/main/utils.ts",
    "ng://ngx-emoji/src/main/ngx-emoji.helper.ts",
    "ng://ngx-emoji/src/main/ngx-emoji.element.ts",
    "ng://ngx-emoji/src/main/ngx-emoji.formatter.ts",
    "ng://ngx-emoji/src/main/ngx-emoji.handler.ts",
    "ng://ngx-emoji/src/main/ngx-emoji.component.ts",
    "ng://ngx-emoji/src/main/ngx-emoji-picker.component.ts",
    "ng://ngx-emoji/src/main/ngx-emoji-with-picker.component.ts",
    "ng://ngx-emoji/src/main/ngx-emoji.module.ts"
  ],
  "sourcesContent": [
    "import { Injectable } from '@angular/core';\nimport { Subject } from \"rxjs/Subject\";\nimport { NgxEmojiComponent } from \"./ngx-emoji.component\";\nimport { NgxEmojiModule } from \"./ngx-emoji.module\";\n\nexport interface NgxEmoji {\n    unified: string;\n    category: string;\n    bundle: number;\n}\n\n@Injectable()\nexport class NgxEmojiService {\n    protected static emojis: NgxEmoji[] = null;\n    public readonly onEmojiPicked: Subject<string> = new Subject<string>();\n    protected activeComponent: NgxEmojiComponent;\n\n    public static getEmojis(): NgxEmoji[] {\n        if (this.emojis === null) {\n            this.emojis = require('ngx-emoji/emojis.json');\n        }\n        return this.emojis;\n    }\n\n    public setActiveComponent(component: NgxEmojiComponent): void {\n        this.activeComponent = component;\n    }\n\n    public isActiveComponent(component: NgxEmojiComponent): boolean {\n        return component === this.activeComponent;\n    }\n\n    public static loadEmoji(emoji: string): void {\n        let bundleId = this.getEmojiBundle(emoji);\n        if (bundleId !== null && !this.isCssBundleLoaded(bundleId)) {\n            this.loadCssBundle(bundleId);\n        }\n    }\n\n    protected static getEmojiBundle(emoji: string): number {\n        for (let e of NgxEmojiService.getEmojis()) {\n            if (e.unified == emoji) {\n                return e.bundle;\n            }\n        }\n        return null;\n    }\n\n    public static loadCssBundle(bundleId: number): void {\n        if (!this.isCssBundleLoaded(bundleId)) {\n            let id = 'ngx-emoji-bundle-' + bundleId;\n            let head = document.getElementsByTagName('head')[0];\n            let link = document.createElement('link');\n            link.id = id;\n            link.rel = 'stylesheet';\n            link.type = 'text/css';\n            link.href = NgxEmojiModule.getEmojiBundlesPath() + 'ngx-emoji-b' + bundleId + '.min.css';\n            link.media = 'all';\n            head.appendChild(link);\n        }\n    }\n\n    public static isCssBundleLoaded(bundleId: number): boolean {\n        return (document.getElementById('ngx-emoji-bundle-' + bundleId)) ? true : false;\n    }\n\n    public recentPush(emoji: string): void {\n        let recent = this.getRecent();\n        if (recent.indexOf(emoji) > -1) {\n            return;\n        }\n        recent = [emoji].concat(recent)\n            .slice(0, NgxEmojiModule.getRecentMax());\n        window.localStorage.setItem('ngx-emoji-recent', recent.join(':'));\n    }\n\n    public getRecent(): string[] {\n        let recent = window.localStorage.getItem('ngx-emoji-recent');\n        if (!recent) {\n            return [];\n        }\n        return recent.split(':');\n    }\n\n}\n",
    "export class NgxEmojiUtils {\n\n    public static arrayOfNodeList<T extends Node>(list: NodeListOf<T>): T[] {\n        let result: T[] = [];\n        for (let i = 0; i < list.length; i++) {\n            result.push(list.item(i))\n        }\n        return result;\n    };\n\n    public static isBlockNode(node: Node): boolean {\n        if (!(node instanceof HTMLElement)) {\n            return false;\n        }\n        if (node instanceof HTMLDivElement) {\n            return true;\n        }\n        return window.getComputedStyle(node, '').display == 'block';\n    }\n\n    /**\n     * String replace all implementation\n     *\n     * See: https://stackoverflow.com/a/1144788/1617101\n     */\n    public static replaceAll(str: string, find: string, replace: string): string {\n        find = find.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n        return str.replace(new RegExp(find, 'g'), replace);\n    }\n\n    public static filterHtml(html: string, allowTags: string[] = [], withCommands: boolean = false): string {\n        allowTags = allowTags.map(function (value) {\n            return value.toUpperCase();\n        });\n        let tmp = document.createElement(\"div\");\n        tmp.innerHTML = html;\n        html = '';\n        let rf = function (nodes: NodeList): void {\n            for (let node of NgxEmojiUtils.arrayOfNodeList(nodes)) {\n                if (node.nodeType == node.ELEMENT_NODE) {\n                    if (node.nodeName == 'BR' && allowTags.indexOf(node.nodeName) > -1) {\n                        html += '<br>';\n                    } else if (allowTags.indexOf(node.nodeName) > -1\n                        || withCommands && (node as HTMLElement).classList.contains('command')) {\n                        if (node instanceof HTMLAnchorElement) {\n                            html += '<' + node.nodeName.toLowerCase() + ' href=\"' + node.getAttribute('href') + '\">';\n                        } else if (withCommands && (node as HTMLElement).classList.contains('command')) {\n                            html += '<' + node.nodeName.toLowerCase() + ' class=\"command\">';\n                        } else {\n                            html += '<' + node.nodeName.toLowerCase() + '>';\n                        }\n                        rf(node.childNodes);\n                        html += '</' + node.nodeName.toLowerCase() + '>';\n                    } else {\n                        rf(node.childNodes);\n                    }\n                } else {\n                    html += node.textContent;\n                }\n            }\n        };\n        rf(tmp.childNodes);\n        tmp.remove();\n        return html;\n    }\n\n}\n",
    "import { NgxEmojiUtils } from \"./utils\";\nimport { NgxEmojiService } from \"./ngx-emoji.service\";\n\nexport class NgxEmojiHelper {\n\n    public static createEmojiImg(emoji: string): string {\n        NgxEmojiService.loadEmoji(emoji);\n        return '<img class=\"ngx-emoji ngx-emoji-' + emoji + '\" ' +\n            'aria-hidden=\"true\" ' +\n            'alt=\"' + this.emojiToSymbol(emoji) + '\" ' +\n            'src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\">';\n    }\n\n    public static emojiToSymbol(emoji: string): string {\n        emoji = emoji.trim();\n        if (emoji.length == 0) {\n            return '�';\n        }\n        let emojiCodes = emoji.split('-').map(function (value) {\n            return parseInt('0x' + value, 16);\n        });\n        try {\n            emoji = String.fromCodePoint.apply(String, emojiCodes);\n        } catch (error) {\n            console.warn('Convert emoji ' + emoji + ' error: ' + error.message);\n            emoji = '�';\n        }\n        return emoji;\n    }\n\n    /**\n     * For debug...\n     */\n    public static dumpEmoji(emoji: string): void {\n        let s: string[] = [];\n        let s2: string[] = [];\n        for (let i = 0; i < emoji.length; i++) {\n            s.push(emoji.codePointAt(i).toString(16).toUpperCase());\n            s2.push(emoji.charCodeAt(i).toString(16).toUpperCase());\n        }\n        console.log(emoji, s, s2);\n    }\n\n    public static emojiFromSymbol(symbol: string): string {\n        let codes: string[] = [];\n        for (let i = 0; i < symbol.length; i++) {\n            codes.push(symbol.codePointAt(i).toString(16));\n        }\n        codes = codes\n            .filter(function (code: string) {\n                let p = parseInt(code, 16);\n                return !(p >= 0xD800 && p <= 0xDFFF);\n            })\n            .map(function (code: string) {\n                let pad = '0000';\n                return pad.substring(0, pad.length - code.length) + code;\n            });\n        return codes.join('-').toUpperCase();\n    }\n\n    public static replaceSymbolsToEmojis(text: string): string {\n        text = text.replace(this.getEmojiRegex(), function (match) {\n            return NgxEmojiHelper.createEmojiImg(NgxEmojiHelper.emojiFromSymbol(match));\n        });\n        text = NgxEmojiUtils.replaceAll(text, '\\uFE0F', ''); // remove variation selector\n        return text;\n    }\n\n    public static isEmojiNode(node: Node): boolean {\n        if (!(node instanceof HTMLElement)) {\n            return false;\n        }\n        return node.classList.contains('ngx-emoji');\n    }\n\n    public static emojiFromNode(node: Node): string {\n        if (!this.isEmojiNode(node)) {\n            return null;\n        }\n        let classList = (node as HTMLElement).classList;\n        let emoji = null;\n        for (let i = 0; i < classList.length; i++) {\n            if (classList.item(i).substr(0, 10) == 'ngx-emoji-') {\n                emoji = classList.item(i).substr(10);\n                break;\n            }\n        }\n        return emoji;\n    }\n\n    /**\n     * See: https://habrahabr.ru/company/badoo/blog/282113/\n     */\n    protected static getEmojiRegex(): RegExp {\n        let emojiRanges = [\n            '(?:\\uD83C[\\uDDE6-\\uDDFF]){2}', // флаги\n            '[\\u0023-\\u0039]\\u20E3', // числа\n            '(?:[\\uD83D\\uD83C\\uD83E][\\uDC00-\\uDFFF]|[\\u270A-\\u270D\\u261D\\u26F9])\\uD83C[\\uDFFB-\\uDFFF]', // цвет кожи\n\n            // семья и профессии\n            '[\\uD83D][\\uDC66-\\uDC69][\\u200D][\\uD83D][\\uDC66-\\uDC69][\\u200D][\\uD83D][\\uDC66-\\uDC67]([\\u200D][\\uD83D][\\uDC66-\\uDC67])?',\n            '[\\uD83D][\\uDC68-\\uDC69][\\u200D][\\u2764][\\u200D][\\uD83D][\\uDC68-\\uDC69]',\n            '[\\uD83D][\\uDC68-\\uDC69][\\u200D][\\u2764][\\u200D][\\uD83D][\\uDC8B][\\u200D][\\uD83D][\\uDC68-\\uDC69]',\n            '[\\uD83D][\\uDC68-\\uDC69][\\u200D][\\uD83C-\\uD83E][\\uDC00-\\uDFFF]',\n            '[\\uD83C-\\uD83E][\\uDC00-\\uDFFF][\\uFE0F]?[\\u200D][\\u2640-\\u2696][\\uFE0F]?',\n            '[\\uD83D][\\uDD75][\\uFE0F][\\u200D][\\u2640][\\uFE0F]',\n            '[\\uD83D][\\uDC68-\\uDC69][\\u200D][\\u2708]',\n            '[\\uD83C-\\uD83E][\\uDC68-\\uDC69][\\u200D][\\uD83C-\\uD83E][\\uDC66][\\u200D][\\uD83C-\\uD83E][\\uDC66]',\n            '[\\u26F9][\\uFE0F][\\u200D][\\u2640-\\u2696][\\uFE0F]',\n\n            '[\\uD83D\\uD83C\\uD83E][\\uDC00-\\uDFFF]', // суррогатная пара\n            '[\\u3297\\u3299\\u303D\\u2B50\\u2B55\\u2B1B\\u27BF\\u27A1\\u24C2\\u25B6\\u25C0\\u2600\\u2705\\u21AA\\u21A9]', // обычные\n            '[\\u203C\\u2049\\u2122\\u2328\\u2601\\u260E\\u261d\\u2620\\u2626\\u262A\\u2638\\u2639\\u263a\\u267B\\u267F\\u2702\\u2708]',\n            '[\\u2194-\\u2199]',\n            '[\\u2B05-\\u2B07]',\n            '[\\u2934-\\u2935]',\n            '[\\u2795-\\u2797]',\n            '[\\u2709-\\u2764]',\n            '[\\u2622-\\u2623]',\n            '[\\u262E-\\u262F]',\n            '[\\u231A-\\u231B]',\n            '[\\u23E9-\\u23EF]',\n            '[\\u23F0-\\u23F4]',\n            '[\\u23F8-\\u23FA]',\n            '[\\u25AA-\\u25AB]',\n            '[\\u25FB-\\u25FE]',\n            '[\\u2602-\\u2618]',\n            '[\\u2648-\\u2653]',\n            '[\\u2660-\\u2668]',\n            '[\\u26A0-\\u26FA]',\n            '[\\u2692-\\u269C]'\n        ];\n        return new RegExp(emojiRanges.join('|'), 'g');\n    }\n\n}\n",
    "import { EventEmitter } from \"@angular/core\";\nimport { NgxEmojiUtils } from \"./utils\";\n\nexport class NgxEmojiElement {\n\n    public readonly onModified: EventEmitter<MutationEvent> = new EventEmitter<MutationEvent>();\n\n    public constructor(\n        public readonly nativeElement: HTMLElement\n    ) {\n        let onModified = this.onModified;\n        nativeElement.addEventListener('DOMSubtreeModified', function (event) {\n            onModified.emit(event as MutationEvent);\n        });\n    }\n\n    public set contentEditable(editable: boolean) {\n        if (editable != this.contentEditable) {\n            this.nativeElement.setAttribute('contenteditable', editable ? 'true' : 'false');\n        }\n    }\n\n    public get contentEditable(): boolean {\n        return this.nativeElement.getAttribute('contenteditable') == 'true';\n    }\n\n    public execCommand(command: string, value?: any): boolean {\n        let editable = this.contentEditable;\n        this.contentEditable = true;\n        let result = false;\n        switch (command) {\n            case 'code':\n                result = this.execCommandTag('code');\n                break;\n            case 'pre':\n                result = this.execCommandTag('pre');\n                break;\n            case 'command':\n                result = this.execCommandTag('span', [{name: 'class', value: 'command'}]);\n                break;\n            default:\n                result = document.execCommand(command, false, value);\n                break;\n        }\n        this.contentEditable = editable;\n        return result;\n    }\n\n    protected execCommandTag(tag: string, attributes: { name: string, value: string }[] = []): boolean {\n        this.execCommand('superscript');\n        let tmp = document.createElement(\"div\");\n        tmp.innerHTML = this.nativeElement.innerHTML;\n        let html = '';\n        let rf = function (nodes: NodeList): void {\n            for (let node of NgxEmojiUtils.arrayOfNodeList(nodes)) {\n                if (node.nodeType == node.ELEMENT_NODE) {\n                    let nodeName = node.nodeName.toLowerCase();\n                    if (nodeName == 'sup') {\n                        nodeName = tag;\n                        html += '<' + tag;\n                        for (let attr of attributes) {\n                            html += ' ' + attr.name + '=\"' + attr.value + '\"';\n                        }\n                        html += '>';\n                    } else {\n                        html += '<' + nodeName;\n                        for (let i = 0; i < node.attributes.length; i++) {\n                            let attr = node.attributes.item(i);\n                            html += ' ' + attr.name + '=\"' + attr.value + '\"';\n                        }\n                        html += '>';\n                    }\n                    rf(node.childNodes);\n                    html += '</' + nodeName + '>';\n                } else {\n                    html += node.textContent;\n                }\n            }\n        };\n        rf(tmp.childNodes);\n        tmp.remove();\n        this.nativeElement.innerHTML = html;\n        return true;\n    }\n\n}",
    "import { NgxEmojiElement } from \"./ngx-emoji.element\";\nimport { NgxEmojiEntityType } from \"./ngx-emoji.component\";\nimport { NgxEmojiHelper } from \"./ngx-emoji.helper\";\n\nexport class NgxEmojiFormatter {\n\n    public constructor(\n        protected readonly element: NgxEmojiElement\n    ) {\n    }\n\n    public formatText(type: NgxEmojiEntityType, value?: string): void {\n        switch (type) {\n            case NgxEmojiEntityType.Bold:\n                this.element.execCommand('bold');\n                break;\n            case NgxEmojiEntityType.Italic:\n                this.element.execCommand('italic');\n                break;\n            case NgxEmojiEntityType.Underline:\n                this.element.execCommand('underline');\n                break;\n            case NgxEmojiEntityType.Pre:\n                this.element.execCommand('pre');\n                break;\n            case NgxEmojiEntityType.Code:\n                this.element.execCommand('code');\n                break;\n            case NgxEmojiEntityType.Strike:\n                this.element.execCommand('strikeThrough');\n                break;\n            case NgxEmojiEntityType.Command:\n                this.element.execCommand('command');\n                break;\n            case NgxEmojiEntityType.TextLink:\n            case NgxEmojiEntityType.Url:\n                this.element.execCommand('createLink', value);\n                break;\n        }\n    }\n\n    public insertNewLine(): void {\n        this.element.execCommand('insertParagraph');\n    }\n\n    public insertEmoji(emoji: string): void {\n        this.element.execCommand(\n            'insertHTML',\n            NgxEmojiHelper.createEmojiImg(emoji)\n        );\n    }\n\n}\n",
    "import { NgxEmojiEntity, NgxEmojiEntityType } from \"./ngx-emoji.component\";\nimport { NgxEmojiUtils } from \"./utils\";\nimport { NgxEmojiElement } from \"./ngx-emoji.element\";\nimport { NgxEmojiHelper } from \"./ngx-emoji.helper\";\nimport { NgxEmojiFormatter } from \"./ngx-emoji.formatter\";\n\nexport class NgxEmojiHandler {\n    public readonly allowedTags = [\n        'b', 'i', 'u', 'strong', 'em',\n        'strike', 'code', 'pre', 'a'\n    ];\n\n    public constructor(\n        protected readonly element: NgxEmojiElement,\n        protected readonly formatter: NgxEmojiFormatter\n    ) {\n    }\n\n    public format(text: string, entities: NgxEmojiEntity[]): void {\n        let handler = this;\n        let nativeElement = this.element.nativeElement;\n        let selection = window.getSelection();\n        let previousRange: Range = (selection.rangeCount) ? selection.getRangeAt(0) : null;\n\n        if (!Array.isArray(entities)) {\n            entities = [];\n        }\n        entities = entities.map(function (entity) {\n            return {\n                offset: entity.offset,\n                length: entity.length,\n                type: handler.normalizeEntityType(entity.type),\n                url: entity.url\n            };\n        }).filter(function (entity) {\n            return entity.type !== null;\n        });\n\n        /* set text */\n\n        text = NgxEmojiUtils.filterHtml(text);\n        text = NgxEmojiUtils.replaceAll(text, '\\u00A0', ' ');\n        text = NgxEmojiUtils.replaceAll(text, '  ', '&nbsp;&nbsp;');\n        text = NgxEmojiHelper.replaceSymbolsToEmojis(text);\n\n        let paragraphs = text.split('\\n');\n        text = '';\n        for (let paragraph of paragraphs) {\n            if (paragraph.length == 0) {\n                paragraph = '<br>';\n            }\n            if (paragraph == ' ') {\n                paragraph = '&nbsp;';\n            }\n            text += '<div>' + paragraph + '</div>';\n        }\n        this.element.nativeElement.innerHTML = text;\n        if (this.element.nativeElement.childNodes.length == 0) {\n            this.element.nativeElement.appendChild(document.createTextNode(''));\n        }\n\n        /* set entities */\n        let endFounded = false;\n        for (let entity of entities) {\n            let range = document.createRange();\n            let offset = 0;\n            let rf = function (nodes: NodeList) {\n                for (let i = 0; i < nodes.length; i++) {\n                    let node = nodes.item(i);\n                    if (NgxEmojiHelper.isEmojiNode(node)) {\n                        let textLength = NgxEmojiHelper.emojiToSymbol(NgxEmojiHelper.emojiFromNode(node)).length;\n                        if (offset <= entity.offset && offset + textLength >= entity.offset) {\n                            range.setStartBefore(node);\n                        }\n                        if (offset <= entity.offset + entity.length && offset + textLength >= entity.offset + entity.length) {\n                            range.setEndAfter(node);\n                            endFounded = true;\n                        }\n                        offset += textLength;\n                    } else {\n                        if (node.hasChildNodes()) {\n                            rf(node.childNodes); // recursion\n                        } else if (node.nodeName != 'BR') {\n                            let textLength = node.textContent.length;\n                            if (offset <= entity.offset && offset + textLength >= entity.offset) {\n                                range.setStart(node, entity.offset - offset);\n                            }\n                            if (offset <= entity.offset + entity.length && offset + textLength >= entity.offset + entity.length) {\n                                range.setEnd(node, entity.offset + entity.length - offset);\n                                endFounded = true;\n                            }\n                            offset += textLength;\n                        }\n                        if (NgxEmojiUtils.isBlockNode(node)) {\n                            offset++;\n                            if (entity.offset + entity.length == offset) {\n                                range.setEndAfter(node.lastChild);\n                                endFounded = true;\n                            }\n                        }\n                    }\n                }\n            };\n            rf(nativeElement.childNodes);\n            if (!endFounded) {\n                range.setEndAfter(nativeElement.lastChild);\n            }\n            selection.removeAllRanges();\n            selection.addRange(range);\n            switch (entity.type) {\n                case NgxEmojiEntityType.TextLink:\n                    this.formatter.formatText(NgxEmojiEntityType.TextLink, entity.url);\n                    break;\n                case NgxEmojiEntityType.Url:\n                    this.formatter.formatText(NgxEmojiEntityType.Url, range.cloneContents().textContent);\n                    break;\n                default:\n                    this.formatter.formatText(entity.type as NgxEmojiEntityType);\n                    break;\n            }\n        }\n\n        selection.removeAllRanges();\n        if (previousRange) {\n            selection.addRange(previousRange);\n        }\n    }\n\n    public getEntities(): NgxEmojiEntity[] {\n        let entities: NgxEmojiEntity[] = [];\n        let rf = function (nodes: NodeList, offset: number): void {\n            for (let node of NgxEmojiUtils.arrayOfNodeList(nodes)) {\n                if (node.textContent.trim().length > 0) {\n                    let nodeName = node.nodeName.toUpperCase();\n                    if (nodeName == 'B' || nodeName == 'STRONG') {\n                        entities.push({\n                            type: NgxEmojiEntityType.Bold,\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                    if (nodeName == 'I' || nodeName == 'EM') {\n                        entities.push({\n                            type: NgxEmojiEntityType.Italic,\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                    if (nodeName == 'U') {\n                        entities.push({\n                            type: NgxEmojiEntityType.Underline,\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                    if (nodeName == 'STRIKE') {\n                        entities.push({\n                            type: NgxEmojiEntityType.Strike,\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                    if (nodeName == 'CODE') {\n                        entities.push({\n                            type: NgxEmojiEntityType.Code,\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                    if (nodeName == 'PRE') {\n                        entities.push({\n                            type: NgxEmojiEntityType.Pre,\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                    if (nodeName == 'A' && node instanceof HTMLAnchorElement\n                        && node.getAttribute('href') == node.textContent) {\n                        entities.push({\n                            type: NgxEmojiEntityType.Url,\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                    if (nodeName == 'A' && node instanceof HTMLAnchorElement\n                        && node.getAttribute('href') != node.textContent) {\n                        entities.push({\n                            type: NgxEmojiEntityType.TextLink,\n                            offset: offset,\n                            length: node.textContent.length,\n                            url: node.textContent\n                        });\n                    }\n                    if (node instanceof HTMLElement && node.classList.contains('command')) {\n                        entities.push({\n                            type: NgxEmojiEntityType.Command,\n                            offset: offset,\n                            length: node.textContent.length\n                        });\n                    }\n                }\n                rf(node.childNodes, offset);\n                offset += node.textContent.length;\n            }\n        };\n        let div = document.createElement('div');\n        div.innerHTML = this.getMarkupHtml(this.element.nativeElement, true);\n        rf(div.childNodes, 0);\n        div.remove();\n        entities = entities.map(function (entity) {\n            if (entity.type == NgxEmojiEntityType.TextLink) {\n                entity.type = 'text_link';\n            } else {\n                entity.type = NgxEmojiEntityType[entity.type as number].toLowerCase();\n            }\n            return entity;\n        });\n        return entities;\n    }\n\n    public getText(): string {\n        return NgxEmojiUtils.filterHtml(this.getMarkupHtml());\n    }\n\n    public getFullHtml() {\n        let html = document.createElement('div');\n        html.innerHTML = this.element.nativeElement.innerHTML;\n        for (let img of NgxEmojiUtils.arrayOfNodeList(html.getElementsByTagName('img'))) {\n            if (!img.classList.contains('ngx-emoji')) {\n                continue;\n            }\n            let emoji = document.createElement('i');\n            emoji.className = img.className;\n            emoji.setAttribute('aria-hidden', 'true');\n            img.parentElement.insertBefore(emoji, img);\n            img.remove();\n        }\n        let result = html.innerHTML;\n        html.remove();\n        return result;\n    }\n\n    public getMarkupHtml(rootElement: HTMLElement = null, withCommands: boolean = false): string {\n        if (!rootElement) {\n            rootElement = this.element.nativeElement;\n        }\n        let html = '';\n        let rf = function (nodes: NodeList): void {\n            for (let node of NgxEmojiUtils.arrayOfNodeList(nodes)) {\n                let blockNode = NgxEmojiUtils.isBlockNode(node);\n                if (node.nodeName == 'PRE') {\n                    blockNode = false;\n                }\n                if (NgxEmojiHelper.isEmojiNode(node)) {\n                    html += NgxEmojiHelper.emojiToSymbol(NgxEmojiHelper.emojiFromNode(node));\n                } else if (node.hasChildNodes()) {\n                    if (!blockNode) {\n                        if (node instanceof HTMLAnchorElement) {\n                            html += '<' + node.nodeName.toLowerCase() + ' href=\"' + node.getAttribute('href') + '\">';\n                        } else if ((node as HTMLElement).classList.contains('command')) {\n                            html += '<' + node.nodeName.toLowerCase() + ' class=\"command\">';\n                        } else {\n                            html += '<' + node.nodeName.toLowerCase() + '>';\n                        }\n                    }\n                    rf(node.childNodes); // recursion...\n                    if (!blockNode) {\n                        html += '</' + node.nodeName.toLowerCase() + '>';\n                    }\n                } else {\n                    html += NgxEmojiUtils.replaceAll(node.textContent, '\\n', '');\n                }\n                if (blockNode && !rootElement.lastChild.isSameNode(node)) {\n                    html += '\\n';\n                }\n                if (node.nodeName == 'BR'\n                    && node.parentNode.firstChild.nodeName != 'BR'\n                    && node.parentNode.childNodes.length != 1\n                    && rootElement.lastChild.lastChild\n                    && !rootElement.lastChild.lastChild.isSameNode(node)) {\n                    html += '\\n';\n                }\n                // hotfix: insert new line after non-block node\n                if (!blockNode\n                    && node.previousSibling\n                    && node.previousSibling.textContent.length > 0\n                    && node.nextSibling\n                    && NgxEmojiUtils.isBlockNode(node.nextSibling)\n                    && node.parentNode.isSameNode(rootElement)) {\n                    html += '\\n';\n                }\n                // hotfix: insert new line after last emoji\n                if (NgxEmojiHelper.isEmojiNode(node)\n                    && (node as HTMLElement).nextElementSibling\n                    && NgxEmojiUtils.isBlockNode((node as HTMLElement).nextElementSibling)\n                    && node.nextSibling.textContent.length == 0) {\n                    html += '\\n';\n                }\n            }\n        };\n        rf(rootElement.childNodes);\n        html = NgxEmojiUtils.replaceAll(html, '\\u00A0', ' ');\n        html = NgxEmojiUtils.replaceAll(html, '&nbsp;', ' ');\n        return NgxEmojiUtils.filterHtml(html, this.allowedTags, withCommands);\n    }\n\n    public setFullHtml(html: string): void {\n        this.element.nativeElement.innerHTML = NgxEmojiUtils.filterHtml(html, this.allowedTags);\n    }\n\n    public setMarkupHtml(html: string): void {\n        html = html.split('\\n').map(function (line, index) {\n            return (index > 0) ? '<div>' + line + '</div>' : line;\n        }).join('');\n        this.element.nativeElement.innerHTML = NgxEmojiUtils.filterHtml(html, this.allowedTags.concat('div'));\n    }\n\n    protected normalizeEntityType(type: any): NgxEmojiEntityType {\n        if (typeof type == 'string') {\n            type = type.toLowerCase();\n        }\n        switch (type) {\n            case 'bold':\n            case NgxEmojiEntityType.Bold:\n                return NgxEmojiEntityType.Bold;\n            case 'italic':\n            case NgxEmojiEntityType.Italic:\n                return NgxEmojiEntityType.Italic;\n            case 'underline':\n            case NgxEmojiEntityType.Underline:\n                return NgxEmojiEntityType.Underline;\n            case 'strike':\n            case NgxEmojiEntityType.Strike:\n                return NgxEmojiEntityType.Strike;\n            case 'code':\n            case NgxEmojiEntityType.Code:\n                return NgxEmojiEntityType.Code;\n            case 'pre':\n            case NgxEmojiEntityType.Pre:\n                return NgxEmojiEntityType.Pre;\n            case 'bot_command':\n            case 'command':\n            case NgxEmojiEntityType.Command:\n                return NgxEmojiEntityType.Command;\n            case 'url':\n            case NgxEmojiEntityType.Url:\n                return NgxEmojiEntityType.Url;\n            case 'text_link':\n            case NgxEmojiEntityType.TextLink:\n                return NgxEmojiEntityType.TextLink;\n            default:\n                return null;\n        }\n    }\n\n    public findCommands(): void {\n        let selection = window.getSelection();\n        if (selection.anchorNode) {\n            let node = selection.anchorNode;\n            if (node.parentElement.classList.contains('command')) {\n                if (node.textContent.trim().length != node.textContent.length) {\n                    /*node.textContent = node.textContent.trim();\n                    let node2 = document.createTextNode(' ');\n                    node.parentElement.parentElement.appendChild(node2);\n                    let range = document.createRange();\n                    range.setStartAfter(node2);\n                    range.collapse(true);\n                    selection.removeAllRanges();\n                    selection.addRange(range);*/\n                }\n            } else {\n                let regex = /(^|\\s)(\\/[a-z0-9]+)($|\\s)/ig;\n                let match: RegExpExecArray;\n                while ((match = regex.exec(node.textContent)) !== null) {\n                    let offset = match.index;\n                    if (match[0].charAt(0) == ' ') {\n                        offset++;\n                    }\n                    let length = match[2].length;\n                    if (match[2].charAt(length - 1) == ' ') {\n                        length--;\n                    }\n                    regex.lastIndex = regex.lastIndex - (match[0].length - match[2].length);\n\n                    let node2 = document.createTextNode(node.textContent.substr(0, offset));\n                    node.textContent = node.textContent.substr(offset + length);\n                    node.parentNode.insertBefore(node2, node);\n                    let span = document.createElement('span');\n                    span.classList.add('command');\n                    span.textContent = match[2].trim();\n                    node.parentNode.insertBefore(span, node);\n                }\n            }\n        }\n    }\n\n    public findLinks(): void {\n        //\n    }\n\n}\n",
    "import { Component, OnDestroy, ElementRef, Input, Output, EventEmitter, HostListener } from '@angular/core';\nimport { NgxEmojiService } from \"./ngx-emoji.service\";\nimport { Subscription } from \"rxjs/Subscription\";\nimport { NgxEmojiPickerComponent } from \"./ngx-emoji-picker.component\";\nimport { NgxEmojiUtils } from \"./utils\";\nimport { NgxEmojiHelper } from \"./ngx-emoji.helper\";\nimport { NgxEmojiElement } from \"./ngx-emoji.element\";\nimport { NgxEmojiFormatter } from \"./ngx-emoji.formatter\";\nimport { NgxEmojiHandler } from \"./ngx-emoji.handler\";\n\nexport interface EnterOn {\n    shift?: boolean;\n    ctrl?: boolean;\n}\n\nexport enum NgxEmojiEntityType {\n    Bold,\n    Italic,\n    Underline,\n    Strike,\n    Code,\n    Pre,\n    Command,\n    Url,\n    TextLink\n}\n\nexport interface NgxEmojiEntity {\n    type: NgxEmojiEntityType | string;\n    offset: number;\n    length: number;\n    url?: string;\n}\n\nexport class NgxEmojiComponentPrevent {\n    public htmlCounter: number = 0;\n    public htmlValue: string = '';\n\n    public fullHtmlCounter: number = 0;\n    public fullHtmlValue: string = '';\n\n    public textCounter: number = 0;\n    public textValue: string = '';\n\n    public entitiesCounter: number = 0;\n    public entitiesValue: NgxEmojiEntity[] = [];\n    public entitiesStringValue: string = '';\n}\n\n@Component({\n    selector: 'ngx-emoji',\n    template: ''\n})\nexport class NgxEmojiComponent implements OnDestroy {\n    private _contenteditable: boolean = false;\n    private _enterOn: EnterOn = {\n        shift: false,\n        ctrl: false\n    };\n\n    protected readonly element: NgxEmojiElement;\n    protected readonly formatter: NgxEmojiFormatter;\n    protected readonly handler: NgxEmojiHandler;\n    protected emojiService: NgxEmojiService;\n    protected emojiServiceSubscription: Subscription = new Subscription();\n    protected lastSelectionRange: Range;\n\n    protected preventCounter: number = 0;\n    protected preventSet: NgxEmojiComponentPrevent = new NgxEmojiComponentPrevent();\n    protected preventGet: NgxEmojiComponentPrevent = new NgxEmojiComponentPrevent();\n\n    @Input('placeholder')\n    public set placeholder(value: string) {\n        this.element.nativeElement.dataset['placeholder'] = value;\n    }\n\n    public constructor(\n        elRef: ElementRef,\n        globalEmojiService: NgxEmojiService\n    ) {\n        let component = this;\n        globalEmojiService.setActiveComponent(this);\n        this.emojiService = globalEmojiService;\n        let subscription = this.emojiService.onEmojiPicked.subscribe(function (emoji: string) {\n            if (globalEmojiService.isActiveComponent(component)) {\n                component.insertEmoji(emoji);\n            }\n        });\n        this.emojiServiceSubscription.add(subscription);\n\n        this.element = new NgxEmojiElement(elRef.nativeElement);\n        this.element.nativeElement.appendChild(document.createTextNode(''));\n        this.formatter = new NgxEmojiFormatter(this.element);\n        this.handler = new NgxEmojiHandler(this.element, this.formatter);\n\n        let range = document.createRange();\n        range.setStart(this.element.nativeElement.firstChild, 0);\n        this.lastSelectionRange = range;\n        this.element.onModified.subscribe(function () {\n            component.preventCounter++;\n            component.onElementModified();\n        });\n\n        /**\n         * see: onFocusout()\n         */\n        if (document.onselectionchange !== undefined) {\n            /*document.addEventListener('selectionchange', function () {\n                component.onSelectionChange();\n            });*/\n        }\n    }\n\n    public ngOnDestroy(): void {\n        this.emojiServiceSubscription.unsubscribe();\n    }\n\n    public addEmojiService(service: NgxEmojiService): void {\n        service.setActiveComponent(this);\n        let component = this;\n        let subscription = service.onEmojiPicked.subscribe(function (emoji: string) {\n            if (service.isActiveComponent(component)) {\n                component.insertEmoji(emoji);\n            }\n        });\n        this.emojiServiceSubscription.add(subscription);\n    }\n\n    /**\n     * Emoji picker\n     */\n\n    @Input('picker')\n    protected set inputPicker(pickerComponent: NgxEmojiPickerComponent) {\n        this.emojiServiceSubscription.unsubscribe();\n        this.emojiServiceSubscription = new Subscription();\n        let service = new NgxEmojiService();\n        service.setActiveComponent(this);\n        this.emojiService = service;\n        pickerComponent.setEmojiService(service);\n        let component = this;\n        let subscription = this.emojiService.onEmojiPicked.subscribe(function (emoji: string) {\n            if (service.isActiveComponent(component)) {\n                component.insertEmoji(emoji);\n            }\n        });\n        this.emojiServiceSubscription.add(subscription);\n    }\n\n    /**\n     * Content editable\n     */\n\n    @Input('attr.contenteditable')\n    protected set attrContenteditable(editable: boolean) {\n        this.contenteditable = editable;\n    }\n\n    @Input('contenteditable')\n    public set contenteditable(editable: boolean) {\n        this._contenteditable = editable;\n        this.element.contentEditable = editable;\n        this.contenteditableChange.emit(editable);\n    }\n\n    public get contenteditable(): boolean {\n        return this._contenteditable;\n    }\n\n    @Output('contenteditableChange')\n    public readonly contenteditableChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n    /**\n     * Enter on\n     */\n\n    @Input('enterOn')\n    public set enterOn(enterOn: EnterOn) {\n        this._enterOn = enterOn;\n        this.enterOnChange.emit(enterOn);\n    }\n\n    public get enterOn(): EnterOn {\n        return this._enterOn;\n    }\n\n    @Output('enterOnChange')\n    public readonly enterOnChange: EventEmitter<EnterOn> = new EventEmitter<EnterOn>();\n\n    public enterKeyIsEnter(): boolean {\n        if (this.onEnter.observers.length == 0) {\n            return false;\n        }\n        return !this.enterKeyIsShiftEnter() && !this.enterKeyIsCtrlEnter();\n    }\n\n    public enterKeyIsCtrlEnter(): boolean {\n        if (this.onEnter.observers.length == 0) {\n            return false;\n        }\n        return (this.enterOn.ctrl) ? true : false;\n    }\n\n    public enterKeyIsShiftEnter(): boolean {\n        if (this.onEnter.observers.length == 0) {\n            return false;\n        }\n        return (this.enterOn.shift) ? true : false;\n    }\n\n    /**\n     * HTML\n     */\n\n    @Input('fullHtml')\n    public set fullHtml(html: string) {\n        if ((this.preventSet.htmlValue != html || this.preventSet.htmlCounter != this.preventCounter)\n            && html != this.html) {\n            this.handler.setFullHtml(html);\n            this.preventSet.fullHtmlValue = html;\n            this.preventSet.fullHtmlCounter = this.preventCounter;\n        }\n    }\n\n    public get fullHtml(): string {\n        if (this.preventGet.fullHtmlCounter != this.preventCounter) {\n            this.preventGet.fullHtmlValue = this.handler.getFullHtml();\n            this.preventGet.fullHtmlCounter = this.preventCounter;\n        }\n        return this.preventGet.fullHtmlValue;\n    }\n\n    @Output('fullHtmlChange')\n    public readonly fullHtmlChange: EventEmitter<string> = new EventEmitter<string>();\n\n    /**\n     * HTML wihout parahraphs\n     */\n\n    @Input('html')\n    public set html(html: string) {\n        if ((this.preventSet.htmlCounter != this.preventCounter || this.preventSet.htmlValue != html)\n            && html != this.html) {\n            this.handler.setMarkupHtml(html);\n            this.preventSet.htmlValue = html;\n            this.preventSet.htmlCounter = this.preventCounter;\n        }\n    }\n\n    public get html(): string {\n        if (this.preventGet.htmlCounter != this.preventCounter) {\n            this.preventGet.htmlValue = this.handler.getMarkupHtml();\n            this.preventGet.htmlCounter = this.preventCounter;\n        }\n        return this.preventGet.htmlValue;\n    }\n\n    @Output('htmlChange')\n    public readonly htmlChange: EventEmitter<string> = new EventEmitter<string>();\n\n    /**\n     * Text\n     */\n\n    @Input('text')\n    public set text(text: string) {\n        if ((this.preventSet.textCounter != this.preventCounter || this.preventSet.textValue != text)\n            && text != this.text) {\n            this.handler.format(text, this.entities);\n            let range = document.createRange();\n            let lastChild = this.element.nativeElement.lastChild;\n            while (lastChild.hasChildNodes()) {\n                lastChild = lastChild.lastChild;\n            }\n            range.setStart(lastChild, lastChild.textContent.length);\n            this.lastSelectionRange = range;\n            this.preventSet.textValue = text;\n            this.preventSet.textCounter = this.preventCounter;\n        }\n    }\n\n    public get text(): string {\n        if (this.preventGet.textCounter != this.preventCounter) {\n            this.preventGet.textValue = this.handler.getText();\n            this.preventGet.textCounter = this.preventCounter;\n        }\n        return this.preventGet.textValue;\n    }\n\n    @Output('textChange')\n    public readonly textChange: EventEmitter<string> = new EventEmitter<string>();\n\n    /**\n     * Entities\n     */\n\n    @Input('entities')\n    public set entities(entities: NgxEmojiEntity[]) {\n        let entitiesJson = JSON.stringify(entities);\n        if ((this.preventSet.entitiesCounter != this.preventCounter || this.preventSet.entitiesStringValue != entitiesJson)\n            && entitiesJson != JSON.stringify(this.entities)) {\n            this.handler.format(this.text, entities);\n            this.preventSet.entitiesStringValue = JSON.stringify(entities);\n            this.preventSet.entitiesCounter = this.preventCounter;\n        }\n    }\n\n    public get entities(): NgxEmojiEntity[] {\n        if (this.preventGet.entitiesCounter != this.preventCounter) {\n            this.preventGet.entitiesValue = this.handler.getEntities();\n            this.preventGet.entitiesCounter = this.preventCounter;\n        }\n        return this.preventGet.entitiesValue;\n    }\n\n    @Output('entitiesChange')\n    public readonly entitiesChange: EventEmitter<NgxEmojiEntity[]> = new EventEmitter<NgxEmojiEntity[]>();\n\n    /**\n     * Enter events\n     */\n\n    @Output('enter')\n    public readonly onEnter: EventEmitter<void> = new EventEmitter<void>();\n\n    @HostListener(\"keydown.enter\", ['$event'])\n    protected onKeydownEnter(event: KeyboardEvent): void {\n        if (!this.contenteditable) {\n            return;\n        }\n        event.preventDefault();\n        if (this.enterKeyIsEnter()) {\n            this.emitEnter();\n        } else {\n            this.formatter.insertNewLine();\n        }\n    }\n\n    @HostListener(\"keydown.control.enter\", ['$event'])\n    protected onKeydownControlEnter(event: KeyboardEvent): void {\n        if (!this.contenteditable) {\n            return;\n        }\n        event.preventDefault();\n        if (this.enterKeyIsCtrlEnter()) {\n            this.emitEnter();\n        } else {\n            this.formatter.insertNewLine();\n        }\n    }\n\n    @HostListener(\"keydown.shift.enter\", ['$event'])\n    protected onKeydownShiftEnter(event: KeyboardEvent): void {\n        if (!this.contenteditable) {\n            return;\n        }\n        event.preventDefault();\n        if (this.enterKeyIsShiftEnter()) {\n            this.emitEnter();\n        } else {\n            this.formatter.insertNewLine();\n        }\n    }\n\n    protected emitEnter(): void {\n        this.textChange.emit(this.text);\n        this.entitiesChange.emit(this.entities);\n        this.fullHtmlChange.emit(this.fullHtml);\n        this.htmlChange.emit(this.html);\n        this.onEnter.emit();\n    }\n\n    /**\n     * Event command\n     */\n\n    @Output('command')\n    public readonly onCommand: EventEmitter<string> = new EventEmitter<string>();\n\n    /**\n     * Event link\n     */\n\n    @Output('link')\n    public readonly onLink: EventEmitter<string> = new EventEmitter<string>();\n\n    /**\n     * Keyboard events\n     */\n\n    @HostListener(\"keydown\", ['$event'])\n    protected onKeydown(event: KeyboardEvent): void {\n        if (event.ctrlKey && event.keyCode == 66) {\n            event.preventDefault();\n            this.formatter.formatText(NgxEmojiEntityType.Bold);\n        }\n        if (event.ctrlKey && event.keyCode == 73) {\n            event.preventDefault();\n            this.formatter.formatText(NgxEmojiEntityType.Italic);\n        }\n        if (event.ctrlKey && event.keyCode == 85) {\n            event.preventDefault();\n            this.formatter.formatText(NgxEmojiEntityType.Underline);\n        }\n    }\n\n    /**\n     * Focus events\n     */\n\n    @HostListener(\"focus\")\n    protected onFocus(): void {\n        this.emojiService.setActiveComponent(this);\n    }\n\n    /**\n     * Get selection before blur don't work in Firefox.\n     * Use hotfix with onSelectionchange()\n     * This is fallback\n     */\n    @HostListener(\"focusout\")\n    protected onFocusout(): void {\n        //if (document.onselectionchange === undefined) {\n        //}\n        let range = window.getSelection().getRangeAt(0);\n        if (this.element.nativeElement.contains(range.startContainer)\n            && this.element.nativeElement.contains(range.endContainer)) {\n            this.lastSelectionRange = range;\n        }\n    }\n\n    protected onSelectionChange(): void {\n        let selection = window.getSelection();\n        if (selection.containsNode(this.element.nativeElement, true)) {\n            this.lastSelectionRange = selection.getRangeAt(0);\n        }\n    }\n\n    /**\n     * Clipboard events\n     */\n\n    @HostListener(\"paste\", ['$event'])\n    protected onPaste(event: ClipboardEvent): void {\n        event.preventDefault();\n        let html = '';\n        if (event.clipboardData.types.indexOf('text/html') > -1) {\n            html = event.clipboardData.getData('text/html');\n        } else if (event.clipboardData.types.indexOf('text/plain') > -1) {\n            html = event.clipboardData.getData('text/plain');\n        }\n        html = html.split('\\n').map(function (line, index) {\n            if (line.trim().length == 0) {\n                line = '<br>';\n            }\n            return (index > 0) ? '<div>' + line + '</div>' : line;\n        }).join('\\n');\n        html = NgxEmojiUtils.filterHtml(html, this.handler.allowedTags.concat(['div', 'br']));\n        html = NgxEmojiHelper.replaceSymbolsToEmojis(html);\n        this.element.execCommand('insertHTML', html);\n    }\n\n    @HostListener(\"copy\", ['$event'])\n    protected onCopy(event: ClipboardEvent): void {\n        let previousRange = window.getSelection().getRangeAt(0);\n        if (previousRange.collapsed) {\n            return;\n        }\n        event.preventDefault();\n        let content: DocumentFragment = window.getSelection().getRangeAt(0).cloneContents();\n        let div = document.createElement('div');\n        div.appendChild(content);\n        div.innerHTML = this.handler.getMarkupHtml(div)\n            .split('\\n')\n            .map(function (value) {\n                if (value.trim().length == 0) {\n                    value = '<br>';\n                }\n                return '<div>' + value + '</div>';\n            })\n            .join('\\n');\n        // Copy HTML hack\n        document.getElementsByTagName('body')[0].appendChild(div);\n        let range = document.createRange();\n        range.setStartBefore(div.firstChild);\n        range.setEndAfter(div.lastChild);\n        let selection = window.getSelection();\n        selection.removeAllRanges();\n        selection.addRange(range);\n        this.element.execCommand('copy');\n        div.remove();\n        selection.removeAllRanges();\n        selection.addRange(previousRange);\n    }\n\n    @HostListener(\"cut\", ['$event'])\n    protected onCut(event: ClipboardEvent): void {\n        this.onCopy(event);\n        this.element.execCommand('delete');\n    }\n\n    /**\n     * Click events\n     */\n\n    @HostListener(\"click\", ['$event'])\n    protected onClick(event: MouseEvent): void {\n        if (this.contenteditable && NgxEmojiHelper.isEmojiNode(event.toElement)) {\n            let range = document.createRange();\n            range.setStartBefore(event.toElement);\n            let selection = window.getSelection();\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n        if (event.toElement.classList.contains('command')) {\n            this.onCommand.emit(event.toElement.textContent);\n        }\n        if (event.toElement instanceof HTMLAnchorElement) {\n            event.preventDefault();\n            this.onLink.emit(event.toElement.getAttribute('href'));\n        }\n    }\n\n    /**\n     * Internal\n     */\n\n    protected onElementModified(): void {\n        //this.handler.findCommands();\n        //this.handler.findLinks();\n\n        if (this.textChange.observers.length > 0) {\n            this.textChange.emit(this.text);\n        }\n        if (this.entitiesChange.observers.length > 0) {\n            this.entitiesChange.emit(this.entities);\n        }\n        if (this.fullHtmlChange.observers.length > 0) {\n            this.fullHtmlChange.emit(this.fullHtml);\n        }\n        if (this.htmlChange.observers.length > 0) {\n            this.htmlChange.emit(this.html);\n        }\n    }\n\n    protected insertEmoji(emoji: string): void {\n        if (!this.contenteditable) {\n            return;\n        }\n        let selection = window.getSelection();\n        selection.removeAllRanges();\n        selection.addRange(this.lastSelectionRange);\n        this.formatter.insertEmoji(emoji);\n        this.emojiService.recentPush(emoji);\n    }\n\n}\n",
    "import { Component, ElementRef, Input } from '@angular/core';\nimport { NgxEmoji, NgxEmojiService } from \"./ngx-emoji.service\";\nimport { NgxEmojiComponent } from \"./ngx-emoji.component\";\n\nexport interface NgxEmojiPickerCategories {\n    [key: string]: NgxEmoji[];\n}\n\n@Component({\n    selector: 'ngx-emoji-picker',\n    template: `<div>\n  <i *ngFor=\"let emoji of getEmojis()\"\n     [class]=\"'ngx-emoji ngx-emoji-' + emoji.unified\"\n     aria-hidden=\"true\"\n     unselectable=\"on\"\n     onselectstart=\"return false;\"\n     (click)=\"emojiPicked(emoji.unified)\"\n  ></i>\n</div>\n<hr>\n<i *ngFor=\"let category of getCategories()\"\n   [class]=\"'ngx-emoji-cat ' + category.class\"\n   unselectable=\"on\"\n   onselectstart=\"return false;\"\n   onmousedown=\"return false;\"\n   aria-hidden=\"true\"\n   (click)=\"selectCategory(category.name)\"\n></i>\n`\n})\nexport class NgxEmojiPickerComponent {\n    protected categories: NgxEmojiPickerCategories = {\n        Recent: [],\n        \"Smileys & People\": null,\n        \"Animals & Nature\": null,\n        \"Food & Drink\": null,\n        Objects: null,\n        \"Travel & Places\": null,\n        Activities: null,\n        Symbols: null,\n        Flags: null\n    };\n    protected currentCategory: string = 'Recent';\n    public readonly nativeElement: HTMLElement;\n\n    public constructor(\n        elRef: ElementRef,\n        protected emojiService: NgxEmojiService\n    ) {\n        this.nativeElement = elRef.nativeElement;\n    }\n\n    public setEmojiService(service: NgxEmojiService): void {\n        this.emojiService = service;\n    }\n\n    @Input('for')\n    protected set inputFor(emojiComponent: NgxEmojiComponent) {\n        this.emojiService = new NgxEmojiService();\n        emojiComponent.addEmojiService(this.emojiService);\n    }\n\n    protected emojiPicked(emoji: string): void {\n        this.emojiService.onEmojiPicked.next(emoji);\n    }\n\n    public selectCategory(category: string): void {\n        this.currentCategory = category;\n    }\n\n    protected loadCategory(category: string): void {\n        let emojis = NgxEmojiService.getEmojis().filter(function (emoji) {\n            return emoji.category == category;\n        });\n        for (let emoji of emojis) {\n            NgxEmojiService.loadEmoji(emoji.unified);\n        }\n        this.categories[category] = emojis;\n    }\n\n    protected getEmojis(): NgxEmoji[] {\n        let category = this.currentCategory;\n        if (category == 'Recent') {\n            let recent: NgxEmoji[] = [];\n            for (let emoji of this.emojiService.getRecent()) {\n                for (let e of NgxEmojiService.getEmojis()) {\n                    if (e.unified == emoji) {\n                        recent.push(e);\n                        NgxEmojiService.loadEmoji(e.unified);\n                        break;\n                    }\n                }\n            }\n            return recent;\n        } else {\n            if (this.categories[category] == null) {\n                this.loadCategory(category);\n            }\n            return this.categories[category];\n        }\n    }\n\n    protected getCategories(): { name: string, class: string }[] {\n        return Object.keys(this.categories).map(function (value) {\n            return {\n                name: value,\n                class: 'ngx-emoji-cat-' + value\n                    .replace('&', '')\n                    .replace('  ', ' ')\n                    .replace(' ', '-')\n                    .toLowerCase()\n            };\n        });\n    }\n\n}\n",
    "import { Component, ViewChild, Input, Output, EventEmitter, ElementRef, OnInit } from \"@angular/core\";\nimport { EnterOn, NgxEmojiComponent, NgxEmojiEntity } from \"./ngx-emoji.component\";\nimport { NgxEmojiPickerComponent } from \"./ngx-emoji-picker.component\";\n\n@Component({\n    selector: 'ngx-emoji-with-picker',\n    template: `<ngx-emoji-picker *ngIf=\"showPicker\" [for]=\"emoji\" #picker></ngx-emoji-picker>\n<ngx-emoji #emoji></ngx-emoji>\n<img *ngIf=\"emoji.contenteditable\"\n     aria-hidden=\"true\"\n     src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\"\n     alt=\"Emoji picker\"\n     [class]=\"showPicker ? 'ngx-emoji-cat-smileys-people' : 'ngx-emoji-cat-smileys-people-inactive'\"\n     (click)=\"togglePicker()\">\n`\n})\nexport class NgxEmojiWithPickerComponent implements OnInit {\n\n    @ViewChild('emoji')\n    protected emojiComponent: NgxEmojiComponent;\n\n    public showPicker: boolean = false;\n\n    public constructor(\n        protected elRef: ElementRef\n    ) {\n    }\n\n    public ngOnInit(): void {\n        this.emojiComponent.contenteditableChange.subscribe((value: boolean) => this.contenteditableChange.emit(value));\n        this.emojiComponent.enterOnChange.subscribe((value: EnterOn) => this.enterOnChange.emit(value));\n        this.emojiComponent.fullHtmlChange.subscribe((value: string) => this.fullHtmlChange.emit(value));\n        this.emojiComponent.htmlChange.subscribe((value: string) => this.htmlChange.emit(value));\n        this.emojiComponent.textChange.subscribe((value: string) => this.textChange.emit(value));\n        this.emojiComponent.entitiesChange.subscribe((value: NgxEmojiEntity[]) => this.entitiesChange.emit(value));\n        this.emojiComponent.onEnter.subscribe(() => this.onEnter.emit());\n        this.emojiComponent.onCommand.subscribe((value: string) => this.onCommand.emit(value));\n        this.emojiComponent.onLink.subscribe((value: string) => this.onLink.emit(value));\n    }\n\n    public togglePicker(): void {\n        this.showPicker = !this.showPicker;\n    }\n\n    @ViewChild('picker')\n    protected set pickerComponent(picker: NgxEmojiPickerComponent) {\n        if (!picker) {\n            return;\n        }\n        let component = this;\n        picker.nativeElement.addEventListener('mouseleave', function () {\n            let timeout = window.setTimeout(function () {\n                component.showPicker = false;\n            }, 1000);\n            picker.nativeElement.addEventListener('mouseenter', function () {\n                window.clearTimeout(timeout);\n            }, {once: true});\n        });\n    }\n\n    /*@HostListener('document:click', ['$event'])\n    protected onClick(event: MouseEvent): void {\n        if (!this.elRef.nativeElement.contains(event.target)) {\n            this.showPicker = false;\n        }\n    }*/\n\n    @Input('placeholder')\n    public set placeholder(value: string) {\n        this.emojiComponent.placeholder = value;\n    }\n\n    @Input('attr.contenteditable')\n    protected set attrContenteditable(editable: boolean) {\n        this.contenteditable = editable;\n    }\n\n    @Input('contenteditable')\n    public set contenteditable(editable: boolean) {\n        this.emojiComponent.contenteditable = editable;\n        this.elRef.nativeElement.setAttribute('contenteditable', false);\n    }\n\n    public get contenteditable(): boolean {\n        return this.emojiComponent.contenteditable;\n    }\n\n    @Output('contenteditableChange')\n    public readonly contenteditableChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n    @Input('enterOn')\n    public set enterOn(enterOn: EnterOn) {\n        this.emojiComponent.enterOn = enterOn;\n    }\n\n    public get enterOn(): EnterOn {\n        return this.emojiComponent.enterOn;\n    }\n\n    @Output('enterOnChange')\n    public readonly enterOnChange: EventEmitter<EnterOn> = new EventEmitter<EnterOn>();\n\n    @Input('fullHtml')\n    public set fullHtml(html: string) {\n        this.emojiComponent.fullHtml = html;\n    }\n\n    public get fullHtml(): string {\n        return this.emojiComponent.fullHtml;\n    }\n\n    @Output('fullHtmlChange')\n    public readonly fullHtmlChange: EventEmitter<string> = new EventEmitter<string>();\n\n    @Input('html')\n    public set html(html: string) {\n        this.emojiComponent.html = html;\n    }\n\n    public get html(): string {\n        return this.emojiComponent.html;\n    }\n\n    @Output('htmlChange')\n    public readonly htmlChange: EventEmitter<string> = new EventEmitter<string>();\n\n    @Input('text')\n    public set text(text: string) {\n        this.emojiComponent.text = text;\n    }\n\n    public get text(): string {\n        return this.emojiComponent.text;\n    }\n\n    @Output('textChange')\n    public readonly textChange: EventEmitter<string> = new EventEmitter<string>();\n\n    @Input('entities')\n    public set entities(entities: NgxEmojiEntity[]) {\n        this.emojiComponent.entities = entities;\n    }\n\n    public get entities(): NgxEmojiEntity[] {\n        return this.emojiComponent.entities;\n    }\n\n    @Output('entitiesChange')\n    public readonly entitiesChange: EventEmitter<NgxEmojiEntity[]> = new EventEmitter<NgxEmojiEntity[]>();\n\n    @Output('enter')\n    public readonly onEnter: EventEmitter<void> = new EventEmitter<void>();\n\n    @Output('command')\n    public readonly onCommand: EventEmitter<string> = new EventEmitter<string>();\n\n    @Output('link')\n    public readonly onLink: EventEmitter<string> = new EventEmitter<string>();\n\n}\n",
    "import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NgxEmojiPickerComponent } from './ngx-emoji-picker.component';\nimport { NgxEmojiComponent } from './ngx-emoji.component';\nimport { NgxEmojiWithPickerComponent } from './ngx-emoji-with-picker.component';\nimport { NgxEmojiService } from './ngx-emoji.service';\nimport 'ngx-emoji/ngx-emoji.min.css';\n\n@NgModule({\n    imports: [\n        CommonModule\n    ],\n    declarations: [\n        NgxEmojiPickerComponent, NgxEmojiComponent, NgxEmojiWithPickerComponent\n    ],\n    providers: [\n        NgxEmojiService\n    ],\n    exports: [\n        NgxEmojiPickerComponent, NgxEmojiComponent, NgxEmojiWithPickerComponent\n    ]\n})\nexport class NgxEmojiModule {\n    protected static emojiBundlesPath: string = 'https://cdn.rawgit.com/arswarog/ngx-emoji/build/ngx-emoji-assets/';\n    protected static recentMax: number = 20;\n\n    public static setEmojiBundlesPath(path: string): void {\n        NgxEmojiModule.emojiBundlesPath = path;\n    }\n\n    public static getEmojiBundlesPath(): string {\n        return NgxEmojiModule.emojiBundlesPath;\n    }\n\n    public static setRecentMax(max: number): void {\n        NgxEmojiModule.recentMax = max;\n    }\n\n    public static getRecentMax(): number {\n        return NgxEmojiModule.recentMax;\n    }\n\n}\n"
  ],
  "names": [
    "NgxEmojiService",
    "this",
    "onEmojiPicked",
    "Subject$1",
    "emojis",
    "require",
    "prototype",
    "setActiveComponent",
    "component",
    "isActiveComponent",
    "activeComponent",
    "bundleId",
    "isCssBundleLoaded",
    "loadCssBundle",
    "e",
    "unified",
    "emoji",
    "bundle",
    "e_1_1",
    "e_1",
    "error",
    "_b",
    "done",
    "_c",
    "_a",
    "return",
    "call",
    "link",
    "id",
    "rel",
    "type",
    "href",
    "NgxEmojiModule",
    "getEmojiBundlesPath",
    "media",
    "head",
    "appendChild",
    "document",
    "getElementById",
    "recent",
    "getRecent",
    "decorators",
    "Injectable",
    "NgxEmojiUtils",
    "window",
    "getComputedStyle",
    "node",
    "display",
    "replaceAll",
    "str",
    "find",
    "replace",
    "RegExp",
    "filterHtml",
    "html",
    "allowTags",
    "withCommands",
    "map",
    "value",
    "toUpperCase",
    "tmp",
    "createElement",
    "innerHTML",
    "rf",
    "nodes",
    "__values",
    "arrayOfNodeList",
    "next",
    "nodeType",
    "ELEMENT_NODE",
    "nodeName",
    "indexOf",
    "HTMLAnchorElement",
    "childNodes",
    "e_2",
    "remove",
    "NgxEmojiHelper",
    "createEmojiImg",
    "loadEmoji",
    "emojiToSymbol",
    "trim",
    "length",
    "emojiCodes",
    "split",
    "parseInt",
    "String",
    "fromCodePoint",
    "apply",
    "console",
    "warn",
    "message",
    "dumpEmoji",
    "s",
    "s2",
    "codes",
    "filter",
    "code",
    "p",
    "substring",
    "join",
    "text",
    "isEmojiNode",
    "HTMLElement",
    "classList",
    "contains",
    "emojiFromNode",
    "i",
    "item",
    "substr",
    "getEmojiRegex",
    "NgxEmojiElement",
    "nativeElement",
    "onModified",
    "EventEmitter",
    "addEventListener",
    "event",
    "emit",
    "Object",
    "defineProperty",
    "set",
    "editable",
    "contentEditable",
    "setAttribute",
    "enumerable",
    "configurable",
    "execCommand",
    "command",
    "result",
    "execCommandTag",
    "name",
    "attributes_1",
    "attributes",
    "attributes_1_1",
    "attr",
    "e_3_1",
    "e_3",
    "textContent",
    "_d",
    "NgxEmojiFormatter",
    "element",
    "NgxEmojiEntityType",
    "Italic",
    "Underline",
    "Pre",
    "Code",
    "Strike",
    "Command",
    "TextLink",
    "Url",
    "insertNewLine",
    "insertEmoji",
    "NgxEmojiHandler",
    "formatter",
    "allowedTags",
    "format",
    "entities",
    "handler",
    "selection",
    "getSelection",
    "previousRange",
    "getRangeAt",
    "Array",
    "isArray",
    "entity",
    "offset",
    "normalizeEntityType",
    "url",
    "paragraphs",
    "replaceSymbolsToEmojis",
    "paragraphs_1",
    "paragraphs_1_1",
    "paragraph",
    "e_5_1",
    "e_5",
    "createTextNode",
    "e_6",
    "endFounded",
    "_loop_1",
    "range",
    "createRange",
    "textLength",
    "setStartBefore",
    "setEndAfter",
    "hasChildNodes",
    "setStart",
    "setEnd",
    "isBlockNode",
    "lastChild",
    "removeAllRanges",
    "addRange",
    "this_1",
    "formatText",
    "cloneContents",
    "entities_1",
    "entities_1_1",
    "e_6_1",
    "getEntities",
    "push",
    "getAttribute",
    "e_7_1",
    "e_7",
    "div",
    "toLowerCase",
    "getMarkupHtml",
    "getElementsByTagName",
    "img",
    "parentElement",
    "insertBefore",
    "e_8_1",
    "e_8",
    "rootElement",
    "blockNode",
    "isSameNode",
    "parentNode",
    "firstChild",
    "previousSibling",
    "nextSibling",
    "e_9",
    "Bold",
    "findCommands",
    "regex",
    "match",
    "exec",
    "index",
    "charAt",
    "lastIndex",
    "span",
    "NgxEmojiComponentPrevent",
    "textValue",
    "entitiesCounter",
    "NgxEmojiComponent",
    "shift",
    "ctrl",
    "enterOnChange",
    "fullHtmlChange",
    "htmlChange",
    "onEnter",
    "onLink",
    "emojiServiceSubscription",
    "add",
    "subscription",
    "elRef",
    "lastSelectionRange",
    "subscribe",
    "preventCounter",
    "onElementModified",
    "addEmojiService",
    "service",
    "emojiService",
    "pickerComponent",
    "setEmojiService",
    "contenteditable",
    "_contenteditable",
    "enterOn",
    "_enterOn",
    "enterKeyIsShiftEnter",
    "enterKeyIsCtrlEnter",
    "observers",
    "get",
    "preventGet",
    "fullHtmlCounter",
    "htmlCounter",
    "htmlValue",
    "textCounter",
    "preventSet",
    "entitiesValue",
    "entitiesJson",
    "JSON",
    "stringify",
    "entitiesStringValue",
    "onKeydownEnter",
    "preventDefault",
    "emitEnter",
    "onKeydownShiftEnter",
    "textChange",
    "entitiesChange",
    "fullHtml",
    "onKeydown",
    "ctrlKey",
    "keyCode",
    "onFocusout",
    "startContainer",
    "endContainer",
    "onSelectionChange",
    "containsNode",
    "onPaste",
    "clipboardData",
    "getData",
    "line",
    "onCopy",
    "collapsed",
    "content",
    "onCut",
    "onClick",
    "toElement",
    "Input",
    "args",
    "Output",
    "HostListener",
    "NgxEmojiPickerComponent",
    "categories",
    "Recent",
    "Smileys & People",
    "Animals & Nature",
    "Food & Drink",
    "Objects",
    "Travel & Places",
    "Activities",
    "emojiComponent",
    "emojiPicked",
    "selectCategory",
    "category",
    "currentCategory",
    "loadCategory",
    "getEmojis",
    "e_10",
    "e_11_1",
    "e_11",
    "e_12",
    "class",
    "inputFor",
    "NgxEmojiWithPickerComponent",
    "showPicker",
    "contenteditableChange",
    "_this",
    "picker",
    "clearTimeout",
    "timeout",
    "once"
  ],
  "mappings": "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"
}
